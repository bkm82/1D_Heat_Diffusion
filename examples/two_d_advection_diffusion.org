#+TITLE: Code Project
#+AUTHOR: Bray Moll
#+OPTIONS: toc:nil
#+SETUPFILE: ~/masters/bray-standard-latex-export.org
#+BIBLIOGRAPHY: citations.bib

* Problem Description
** Integral Equation
This problem considers the 2 dimensional advection diffusion equation, which in its integral form can be written as
\begin{equation}
\frac{d}{dt} \int _\Omega \phi  d\Omega = - \int _S \phi \textbf{V} \cdot \textbf{n} dS  \int _S \alpha \nabla \phi \cdot \textbf{n} dS + \int _\Omega Q d\Omega
\end{equation}

** Descriptions
Part 1 condsiders the steady state problem with no advection or generation terms for a thin water column with the spatial domain of  $x \epsilon(0,5m)$ and $y \epsilon(0,1m)$ with a dirichlet boundary conditions of $30^{\circ} c$ on the left, bottom, and top surface and a neumann boundary condition of $q = 10 \frac{W}{m^2}$ on the top surface

Part 2 condsiders the same formulation as part 1 with an added source term $Q = 50e^{-(x-\frac{L}{2})^2}$

Part 3 considers the unsteady case of part 1, starting from an initial condition of $T(0,x,y) = 30^{\circ} c$ until a steady state is achieved

Part 4 considers the advection-diffusion problem with a left dirichelet boundary condition of $50 ^{\circ} c$, for three constant velocities $\textbf{V} = [1,0], [10,0], [100,0] m/s$
** Discritized Equations
The first term of equation 1 discritized on a cartesian structured grid by approximating the volumetric inegral's average as being its center point and discritizing the time derivative using a forward discritization.
\begin{equation}
\frac{d}{d t} \int _\Omega  \phi d\Omega = \frac{d}{d t} \bar{\phi}\Delta x \Delta y \approx \frac{d}{d t} \phi _i\Delta x \Delta y \approx \frac{\phi^{n+1} _i - \phi ^ n _i}{\Delta t} \Delta x \Delta y + O(\Delta t)
\end{equation}

Due to the velocitys all being in the positive x direction, the second term can be discritized using an upwind discritization.
\begin{equation}
 -\int _S \phi \textbf{V} \cdot \textbf{n} dS   \approx u_x(\phi_L - \phi _i) \Delta y +O(\Delta x , \Delta t)
\end{equation}
where u_x is the velocity magnitude in the x direction and $\phi _W$ coresponds to value of phi for the cell next to the current cell in the the west cardinal dircetion. Of note, the $\Delta x$ discritization here will make the entire equation 1st order accurate spatial discritization. Note: The convection of refering to the cells surrounding the current cell as N = North, E = East, W = West, S = South
and the lowercase equivalent refering to the respective face intersections between will be used throuhout this report)

the third diffusive flux term can be discritized using the central difference. Assuming a constant diffusivity paramater this results in

\begin{equation}
 \int _S \alpha \nabla \phi \cdot \textbf{n} dS \approx \alpha \frac{\phi _L -2 \phi _i +\phi _R}{\Delta x} \Delta y + \alpha \frac{\phi _S -2 \phi _i +\phi _N}{\Delta y} \Delta x + O(\Delta x^2 ,\Delta y^2)
\end{equation}

The last source term can again be approximated as the value at its mid point

\begin{equation}
\int _\Omega Q d\Omega \approx Q_i\Delta x \Delta y
\end{equation}

Combining the equations 2 - 5 and deviding both sided by $\Delta x \Delta y$ and multipying the source term (given in units of $\frac{W}{m^2}$) by $\frac{\alpha}{k}$ results in the final discritized equation
\begin{equation}
\frac{\phi^{n+1} _i - \phi ^ n _i}{\Delta t} = \frac{u_x(\phi_L - \phi _i)}{\Delta x} + \alpha \frac{\phi _L -2 \phi _i +\phi _R}{\Delta x ^2} + \alpha \frac{\phi _S -2 \phi _i +\phi _N}{\Delta y^2} + \ Q_i \frac{\alpha}{k} +O(\Delta t, \Delta x, \Delta y)
\end{equation}

Finally, the source term was given in

** Boundary Conditions
For the boundary conditions, we can modify equation 6 on the boundaries using the ghost cell approach using the known quantities. Shown here for the left dirichlet boundaries
\begin{equation}
\frac{\phi _L+ \phi _i}{2} = T_{left}
\end{equation}
allows solving for the dirichlet equations on the boundaries
\begin{equation}
\phi _L = 2T_{left}-\phi _i
\end{equation}
Simillarly for the right
\begin{equation}
\phi _R = 2T_{right}-\phi _i
\end{equation}
and bottom boundaries
\begin{equation}
\phi _S = 2T_{bottom}-\phi _i
\end{equation}
The neumann boundary can be determined from the flux term
\begin{equation}
q = k \frac{\delta T}{\delta y} \approx k \frac{\phi _N - \phi _i}{\Delta y}
\end{equation}
where k is the materials thermal conductivity.
Solving for $\phi _n$
\begin{equation}
\phi _N = \frac{q \Delta y}{k} +\phi _i
\end{equation}


\newpage
* Problem Constants
Based on the problem description, at atmospheric pressure the thermal diffusivity ranges from $0.155 *10^{-6} \frac{m^2}{s}$ at 50 degrees celcius, to $0.143 * 10^ {-6} \frac{m^2}{s}$ at 20 degrees celsius. A constant thermal diffusivity of $0.146 * 10^{-6} /frac{m^2}{s}$ for water at standard temperature and pressure (25 degrees celcius at atmospheric pressure) was used for this project as the error introduced due to this symplifying assumption was determined to be acceptable [cite:@Water_Diffusion_EngineeringToolbox]

The water thermal conductivity taken to be a constant at $0.456 \frac{W}{mK}$ again coresponding to a temperature of 25 degrees celcius. [cite:@Water_Conductivity_EngineeringToolBox]

#+ATTR_LATEX: :options frame=single
#+BEGIN_SRC python :results output :exports both :session Python-Session
  from solver.cartesian_mesh import CartesianMesh
  from solver.solver import Solver
  from solver.utilities import EnergyBalance
  from solver.mesher import linear_convection_mesh
  from matplotlib import pyplot as plt
  import numpy as np
  import logging
  import math

  #create logging configuration
  logger = logging.getLogger(__name__)
  logger.setLevel(logging.DEBUG)

  console_handler = logging.StreamHandler()
  console_handler.setLevel(logging.DEBUG)
  formatter = logging.Formatter(
    "%(message)s",
  )
  console_handler.setFormatter(formatter)
  logger.addHandler(console_handler)

  #Define a various mesh sizes with non equal cell widths and heights
  mesh_size_dict = {
     "course":(5,2),
     "medium": (20,8),
     "fine":(100,10),
     "ultra_fine":(200,50)
  }
  # Define Problem constants
  x_range = (0,5)
  y_range = (0,1)
  mesh_type = "finite_volume"
  conductivity = 0.456 ## W/mK
  diffusivity = 0.146*10**(-6) #m^2/s
  temp_left = 30  ## decrees celcius
  temp_right = 30 ## degrees celcius
  temp_bottom = 30 # degrees celsius
  top_flux = -10 #W/m
 #+END_SRC

 #+RESULTS:

* Part 1 Steady State
#+ATTR_LATEX: :options frame=single
#+BEGIN_SRC python :results output :exports both :session Python-Session
  #Define a various mesh sizes with non equal cell widths and heights
  mesh_dict = {}
  energy_balance_dict = {}
  for mesh_size , cells in mesh_size_dict.items():
      x_cells , y_cells  = cells

      mesh_dict[mesh_size] = CartesianMesh(
          dimensions=2,
          n_cells=[x_cells, y_cells],
          cordinates=[x_range, y_range],
          mesh_type= mesh_type,
          conductivity = conductivity,
          diffusivity = diffusivity
      )

      mesh_dict[mesh_size].set_dirichlet_boundary(side="left", phi=temp_left)
      mesh_dict[mesh_size].set_dirichlet_boundary(side="right", phi=temp_right)
      mesh_dict[mesh_size].set_dirichlet_boundary(side="bottom", phi=temp_bottom)
      mesh_dict[mesh_size].set_neumann_boundary(side="top", flux = top_flux/conductivity)

      # Solve the steady Case
      Solver(mesh = mesh_dict[mesh_size]).solve_steady()
      energy_balance_dict[mesh_size] = EnergyBalance(mesh = mesh_dict[mesh_size])
      logger.info(f"\n Mesh Size:{mesh_size}")
      total_flux = energy_balance_dict[mesh_size].flux("all")
#+END_SRC

#+RESULTS:
#+begin_example

 Mesh Size:course
solver.utilities:INFO:flux:
 Left Flux: 5.984599731767105 W
 Right Flux: 5.984599731767105 W
 Bottom Flux: 38.03080053646583 W
 Generation: 0.0 W
 Top Flux: -50.0 W
 Cell Sum Squared Error: 8.131861707906003e-28 W
 Flux leaving boundarys: 4.440892098500626e-14W
 Total Flux: 4.440892098500626e-14

 Mesh Size:medium
solver.utilities:INFO:flux:
 Left Flux: 7.330052111172102 W
 Right Flux: 7.330052111172095 W
 Bottom Flux: 35.339895777655755 W
 Generation: 0.0 W
 Top Flux: -50.0 W
 Cell Sum Squared Error: 2.2277109653610886e-26 W
 Flux leaving boundarys: -5.684341886080802e-14W
 Total Flux: -5.684341886080802e-14

 Mesh Size:fine
solver.utilities:INFO:flux:
 Left Flux: 7.410898164506065 W
 Right Flux: 7.4108981645061895 W
 Bottom Flux: 35.178203670991046 W
 Generation: 0.0 W
 Top Flux: -49.99999999999999 W
 Cell Sum Squared Error: 1.7166707559454444e-25 W
 Flux leaving boundarys: 3.304023721284466e-12W
 Total Flux: 3.304023721284466e-12

 Mesh Size:ultra_fine
solver.utilities:INFO:flux:
 Left Flux: 7.417294624355647 W
 Right Flux: 7.417294624356283 W
 Bottom Flux: 35.165410751328 W
 Generation: 0.0 W
 Top Flux: -50.0 W
 Cell Sum Squared Error: 1.6155439387848486e-24 W
 Flux leaving boundarys: 3.991829089500243e-11W
 Total Flux: 3.991829089500243e-11
#+end_example

Due to the finite volume scheme, the total flux error and the sum of each cells squared error is relativly independent of mesh size. The overall error increases slightly with the higher number of points due to the numerical round off error present with the higher number of calcualtions.

#+ATTR_LATEX: :options frame=single
#+BEGIN_SRC python :results graphics file :file steady.png :exports results :session Python-Session
  fig, ax = plt.subplots(len(mesh_dict), figsize= (10,12))
  i = 0
  for  mesh_size, mesh in mesh_dict.items():

      x_cords = mesh.grid["x_grid"].cell_cordinates
      y_cords = mesh.grid["y_grid"].cell_cordinates
      logger.debug(x_cords)
      xv, yv = np.meshgrid(x_cords, y_cords)
      axis = plt.subplot(len(mesh_dict),1,i+1)
      axis.set_title(mesh_size)
      steady = axis.pcolormesh(xv, yv, mesh.phi.get_phi())

      i = i +1


      fig.colorbar(steady, label = "temperature (celcius)")
  plt.savefig("steady.png")


#+END_SRC

#+RESULTS:
[[file:steady.png]]

* Part 2: With Generation
#+ATTR_LATEX: :options frame=single
#+BEGIN_SRC python :results output :exports both :session Python-Session
  generation_mesh_dict = {}
  generation_energy_balance_dict = {}
  def gen_function (x, y):
      return(0*y+ 50*np.exp(-(x-2.5)**2))
  for mesh_size , cells in mesh_size_dict.items():
      x_cells , y_cells  = cells
      generation_mesh_dict[mesh_size] = CartesianMesh(
          dimensions=2,
          n_cells=[x_cells, y_cells],
          cordinates=[x_range, y_range],
          mesh_type= mesh_type,
          conductivity = conductivity,
          diffusivity = diffusivity
      )

      generation_mesh_dict[mesh_size].set_dirichlet_boundary(side="left", phi=temp_left)
      generation_mesh_dict[mesh_size].set_dirichlet_boundary(side="right", phi=temp_right)
      generation_mesh_dict[mesh_size].set_dirichlet_boundary(side="bottom", phi=temp_bottom)
      generation_mesh_dict[mesh_size].set_neumann_boundary(side="top", flux = top_flux/conductivity)
      generation_mesh_dict[mesh_size].set_generation(function = gen_function)

      # Solve the steady Case with generation
      Solver(mesh = generation_mesh_dict[mesh_size]).solve_steady()
      generation_energy_balance_dict[mesh_size] = EnergyBalance(mesh = generation_mesh_dict[mesh_size])
      logger.info(f"\n Mesh Size:{mesh_size}")
      total_flux = generation_energy_balance_dict[mesh_size].flux("all")

#+END_SRC

#+RESULTS:
#+begin_example

 Mesh Size:course
solver.utilities:INFO:flux:
 Left Flux: 3.050929235793739 W
 Right Flux: 3.050929235793736 W
 Bottom Flux: -44.721366477605116 W
 Generation: 88.61950800601765 W
 Top Flux: -50.0 W
 Cell Sum Squared Error: 1.3769936879182083e-27 W
 Flux leaving boundarys: -88.61950800601764W
 Total Flux: 1.9984014443252818e-14

 Mesh Size:medium
solver.utilities:INFO:flux:
 Left Flux: 4.701073325592375 W
 Right Flux: 4.70107332559235 W
 Bottom Flux: -47.991201972823 W
 Generation: 88.58905532163828 W
 Top Flux: -50.0 W
 Cell Sum Squared Error: 2.551527219976484e-26 W
 Flux leaving boundarys: -88.58905532163827W
 Total Flux: 1.2878587085651816e-14

 Mesh Size:fine
solver.utilities:INFO:flux:
 Left Flux: 4.785512273955572 W
 Right Flux: 4.785512273955726 W
 Bottom Flux: -48.157752314938016 W
 Generation: 88.58672776703278 W
 Top Flux: -49.99999999999999 W
 Cell Sum Squared Error: 3.4356761443066776e-25 W
 Flux leaving boundarys: -88.58672776702672W
 Total Flux: 6.0751403907488566e-12

 Mesh Size:ultra_fine
solver.utilities:INFO:flux:
 Left Flux: 4.804574739708152 W
 Right Flux: 4.804574739708852 W
 Bottom Flux: -48.195801968524805 W
 Generation: 88.58665248917005 W
 Top Flux: -50.0 W
 Cell Sum Squared Error: 3.482364056824771e-24 W
 Flux leaving boundarys: -88.5866524891078W
 Total Flux: 6.225775450729998e-11
#+end_example

#+ATTR_LATEX: :options frame=single
#+BEGIN_SRC python :results graphics file :file generation.png :exports results :session Python-Session
  fig, ax = plt.subplots(len(generation_mesh_dict), figsize= (10,12))
  i = 0
  for  mesh_size, mesh in generation_mesh_dict.items():

      x_cords = mesh.grid["x_grid"].cell_cordinates
      y_cords = mesh.grid["y_grid"].cell_cordinates
      logger.debug(x_cords)
      xv, yv = np.meshgrid(x_cords, y_cords)
      axis = plt.subplot(len(generation_mesh_dict),1,i+1)
      axis.set_title(mesh_size)
      steady = axis.pcolormesh(xv, yv, mesh.phi.get_phi())

      i = i +1


      fig.colorbar(steady, label = "temperature (celcius)")
  plt.savefig("generation.png")


#+END_SRC

#+RESULTS:
[[file:generation.png]]

In the generation case you can see the overall energy balance still holds for the finite volume discritization regardless of discritization size. As expected, the energy generated is balanced by the energy leaving the control volume. The source term was strong enough to have a flux out of the control volume on the 4 dirichilet boundaries. Of note in this case is that even though the generation term was constant in the Y axis, the temperature distribution is shifted towards the upper bound due to the fixed flux of $10 W/m$ being less than the bottom flux (which is ~ $20 \frac{W}{m}$ but would not be constant across the boundary. Also of note, the maximum temperature reached was ~ 90 degrees celcius which is approaching a range where, depending on the application, the assumption of a constant thermal conductivity could be introducing a non-negligable amound of error into calculating the solution.

* Part 3: Transient

To obtain a rough estimate the time to perform the simulation we can use the formula
\begin{equation*}
\frac{Water Mass * (T _{final} - T _{start}) * Specific Heat}{Cooling Rate}
\end{equation*}

Aproximating the cooling rate as being the average of its starting rate (50W from the top) and 0W (steady state) = 25W.

The temperatures are 30 celcius and the average temperature seen in the steady state case.
At these temperatures, the isobaric and isochoric specific heats are aproximatly equivalent at 4.1379 kJ/kgK [cite:@Water_Specific_Heat_EngineeringToolBox]

\begin{equation*}
\frac{5 (m) * 1 (m) * \frac{1000 kg}{m^3} * (T _{final} -30 )K * 41379 \frac{J}{kgK}}{-25 \frac{J}{s m^2} } =
\end{equation*}
where L is the lenght into the page
#+ATTR_LATEX: :options frame=single
#+BEGIN_SRC python :results output :exports both :session Python-Session

  average_final_temp =np.mean(mesh_dict["fine"].phi.get_phi())
  time_estimate = ((5*1)*1000*(average_final_temp - 30)*41379)/(-25)
  logger.info(f"Time Estimate: {time_estimate}s")
#+END_SRC

#+RESULTS:
: Time Estimate: 67171960.47650723s

This time estimate can also be obtained using the einstein's approximation equations [cite:@Diffusion_Time_Calculator]

\begin{equation}
 t \approx \frac{x ^2}{alpha} = \frac{1 m^2}{2* 0.146 *10^{-6}\frac{m^2}{s}} \approx 0.2 *10 ^6 seconds
\end{equation}

This shows that the time scales of interest are on the order of 1 million seconds. Recalling that for an explicit solver we need
\begin{equation*}
\Delta t \le \frac{\Delta x ^2}{2\alpha ^2}
\end{equation*}
With a realistic desired discritization size of $\Delta x = 0.01$ and our thermal diffusivity of $0.146 *10 ^{-6} \frac{m^2}{s}$ an Explicit solver would require a time step size on the order of 100 seconds which would require roughly 10^4 time steps for the finer meshes.For this reason an implicit solver was chosen.

#+ATTR_LATEX: :options frame=single
#+BEGIN_SRC python :results output :exports both :session Python-Session
  #Define a various mesh sizes with non equal cell widths and heights

  transient_mesh = CartesianMesh(
    dimensions = 2,
    n_cells = [80, 12],
    cordinates = [(0,5), (0,1)],
    mesh_type = "finite_volume",
    conductivity = conductivity,
    diffusivity = diffusivity
  )

  transient_mesh.set_dirichlet_boundary(side="left", phi=temp_left)
  transient_mesh.set_dirichlet_boundary(side="right", phi=temp_left)
  transient_mesh.set_dirichlet_boundary(side="bottom", phi=temp_left)
  transient_mesh.set_neumann_boundary(side="top", flux=-10/conductivity)

  #Set the initial condition
  transient_mesh.phi.set_phi(30)

  logger.debug(f"Initial phi {transient_mesh.phi.get_phi()}")
  logger.info(f"Steady Average Temerpature phi {average_final_temp}")

  #Create the implicit solver
  transient_solver = Solver(
      mesh = transient_mesh,
      method = "implicit",
      time_step_size = 10000
  )

  record_time_step_time = 500000
  max_time = 50000000
  transient_dict[0] = transient_mesh.phi.get_phi()
  time = 0
  while time < max_time:
      time = transient_solver.current_time
      transient_solver.solve(
          t_initial = time,
          t_final = time + record_time_step_time)
      current_average_temp = np.mean(transient_mesh.phi.get_phi())
      error = (
          current_average_temp - average_final_temp) / (average_final_temp) *100
      logger.info(f"Time : {transient_solver.current_time} s, Average Temp {current_average_temp}, error: {round(error,2)}%")
      transient_dict[time+record_time_step_time] = transient_mesh.phi.get_phi()
      if error < 0.1:
          break

      if time >= max_time:
          logger.warning(f"The max time was reached without convergance")

  logger.debug(f"Phi{transient_mesh.phi.get_phi()}")



#+END_SRC

#+RESULTS:
#+begin_example
Steady Average Temerpature phi 21.883327234042966
Time : 500000 s, Average Temp 28.535267554470284, error: 30.4%
Time : 1000000 s, Average Temp 27.268397546435594, error: 24.61%
Time : 1500000 s, Average Temp 26.22997299732739, error: 19.86%
Time : 2000000 s, Average Temp 25.3933422332038, error: 16.04%
Time : 2500000 s, Average Temp 24.720514075546923, error: 12.97%
Time : 3000000 s, Average Temp 24.17868791987837, error: 10.49%
Time : 3500000 s, Average Temp 23.741637048545964, error: 8.49%
Time : 4000000 s, Average Temp 23.38860713122911, error: 6.88%
Time : 4500000 s, Average Temp 23.10312964767548, error: 5.57%
Time : 5000000 s, Average Temp 22.872078322334737, error: 4.52%
Time : 5500000 s, Average Temp 22.684949712392886, error: 3.66%
Time : 6000000 s, Average Temp 22.533312966793243, error: 2.97%
Time : 6500000 s, Average Temp 22.410384452649232, error: 2.41%
Time : 7000000 s, Average Temp 22.310695589073646, error: 1.95%
Time : 7500000 s, Average Temp 22.22983135278154, error: 1.58%
Time : 8000000 s, Average Temp 22.164223107456003, error: 1.28%
Time : 8500000 s, Average Temp 22.110983651304984, error: 1.04%
Time : 9000000 s, Average Temp 22.067775360645264, error: 0.84%
Time : 9500000 s, Average Temp 22.032704457817463, error: 0.68%
Time : 10000000 s, Average Temp 22.004236014472575, error: 0.55%
Time : 10500000 s, Average Temp 21.981125486248704, error: 0.45%
Time : 11000000 s, Average Temp 21.962363474600636, error: 0.36%
Time : 11500000 s, Average Temp 21.947131102737938, error: 0.29%
Time : 12000000 s, Average Temp 21.934763928817294, error: 0.24%
Time : 12500000 s, Average Temp 21.92472273889567, error: 0.19%
Time : 13000000 s, Average Temp 21.916569892386672, error: 0.15%
Time : 13500000 s, Average Temp 21.909950154298546, error: 0.12%
Time : 14000000 s, Average Temp 21.904575156636994, error: 0.1%
#+end_example


#+ATTR_LATEX: :options frame=single
#+BEGIN_SRC python :results graphics file :file transient.png :exports both :session Python-Session
  fig, axes = plt.subplots(4, figsize= (10,12))
  dict_length = len(transient_dict)
  i = 0
  for  row, ax in zip([500000,5000000, 10000000, 14000000], axes.flat):

      x_cords = transient_mesh.grid["x_grid"].cell_cordinates
      y_cords = transient_mesh.grid["y_grid"].cell_cordinates
      logger.debug(row)
      xv, yv = np.meshgrid(x_cords, y_cords)
      #axis = plt.subplot(3,1,i+1)
      #axis.set_title(row)
      im = ax.pcolormesh(xv, yv, transient_dict[row])
      ax.set_title(f"time {row}s")
      i = i +1

  fig.colorbar(im, ax = axes.ravel().tolist(), label = "temperature (celcius)")
  plt.savefig("transient.png")

#+END_SRC

#+RESULTS:
[[file:transient.png]]

* Part 4: Advection Diffusion



#+ATTR_LATEX: :options frame=single
#+BEGIN_SRC python :results none:exports both :session Python-Session
  x_cells = 40
  y_cells = 20
  diffusivity = 0.146
  transient_mesh = CartesianMesh(
    dimensions = 2,
    n_cells = [x_cells, y_cells],
    cordinates = [(0,5), (0,1)],
    mesh_type = "finite_volume",
    conductivity = conductivity,
    diffusivity = diffusivity
  )

  transient_mesh.set_dirichlet_boundary(side="left", phi=50)
  transient_mesh.set_dirichlet_boundary(side="right", phi=temp_right)
  transient_mesh.set_dirichlet_boundary(side="bottom", phi=temp_bottom)

  transient_mesh.set_neumann_boundary(side="top", flux=-10/conductivity)

  #Set the initial condition
  transient_mesh.phi.set_phi(30)

  #Create a laplacian and boundary condition to update the diffuison mesh
  ux = 1
  convection_mesh = linear_convection_mesh(
      x = x_range,
      n_cells= x_cells,
      mesh_type= "finite_volume",
      discretization_type= "upwind")

  convection_mesh.set_dirichlet_boundary("left", phi = 50)


  dx = transient_mesh.grid["x_grid"].cell_width
  Iy = np.identity(y_cells)

  twod_x_lap = (ux/dx) * np.kron(Iy,convection_mesh.laplacian)
  #logger.debug(f"{twod_x_lap}")


  twod_x_bc = (ux/(dx)) * convection_mesh.boundary_condition_array.reshape(1,x_cells).repeat(y_cells, axis = 0).flatten()

  #logger.debug(f"{(ux/dx) * convection_mesh.boundary_condition_array.reshape(1,x_cells).repeat(y_cells, axis = 0)}")




  #add the convective portion to the mesh
  #logger.debug(f"conv laplacian:\n {twod_x_lap}")
  #logger.debug(f"laplacian: pre add conv \n {transient_mesh.laplacian}")
  transient_mesh.laplacian = transient_mesh.laplacian + twod_x_lap
  #logger.debug(f"laplacian: post add conv \n {transient_mesh.laplacian}")
  transient_mesh.boundary_condition_array = transient_mesh.boundary_condition_array + twod_x_bc
  ##############################################################
  solver_step_size = 5/(100*ux)
  round_threshold = 2+ len(str(round(solver_step_size)))

  logger.debug(f"sover_step_size: {solver_step_size}")

  #Create the implicit solver
  transient_solver = Solver(
      mesh = transient_mesh,
      method = "implicit",
      time_step_size = solver_step_size

  )
  transient_list = []
  record_time_step_time = solver_step_size * 10

  max_time = solver_step_size *1000
  #transient_solver.solve_steady()
  transient_dict[0] = transient_mesh.phi.get_phi().copy()
  #logger.debug(f"dict_0 {transient_dict[0]}")

  transient_mesh.phi.set_phi(30)
  time = 0
  while time < max_time:

      transient_solver.solve(
          t_initial = time,
          t_final = time + record_time_step_time)

      time = round(
          transient_solver.current_time,
          round_threshold
      )

      logger.debug(f"time : {time}")

      #transient_dict[time] = transient_mesh.phi.get_phi()
      transient_list.append({time:transient_mesh.phi.get_phi()})


#+END_SRC

#+RESULTS:


#+ATTR_LATEX: :options frame=single
#+BEGIN_SRC python :results graphics file :file advection_transient.png :exports both :session Python-Session
  fig, axes = plt.subplots(3, figsize= (10,12))
  list_length = len(transient_list)
  i = 0
  for  row, ax in zip([0, round(list_length/2), list_length-1], axes.flat):
      for time, data in transient_list[row].items():

          x_cords = transient_mesh.grid["x_grid"].cell_cordinates
          y_cords = transient_mesh.grid["y_grid"].cell_cordinates

          xv, yv = np.meshgrid(x_cords, y_cords)
          #axis = plt.subplot(3,1,i+1)
          #axis.set_title(row)
          im = ax.pcolormesh(xv, yv, data)
          ax.set_title(f"time {time}s")
          i = i +1
          fig.colorbar(im, label ="temp")
  #fig.colorbar(im, ax = axes.ravel().tolist(), label = "temperature (celcius)")
  plt.savefig("advection_transient.png")

#+END_SRC

#+RESULTS:
[[file:advection_transient.png]]
